<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/krVMYr2.png" alt="Project Logo"></a>
</p>

## üìñ Version / –í–µ—Ä—Å–∏—è
- [üá∑üá∫ RU](#RU)
- [üá∫üá∏ ENG](#ENG)

---

## üá∑üá∫ RU <a name="RU"></a>

## üìù –°–æ–¥–µ—Ä–∂–∏–º–æ–µ

- [–û –ø—Ä–æ–µ–∫—Ç–µ](#aboutRU)
- [–ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã](#how_it_worksRU)
- [–ê–Ω–∞–ª–∏–∑ —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–π](#hash_functionsRU)
- [–ü–ª–∞—Ç—Ñ–æ—Ä–º–æ–∑–∞–≤–∏—Å–∏–º—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏](#optimizationsRU)
- [–ó–∞–∫–ª—é—á–µ–Ω–∏–µ](#conclusionRU)
- [–£—Å—Ç–∞–Ω–æ–≤–∫–∞](#installationRU)
- [–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã](#built_usingRU)
- [–ê–≤—Ç–æ—Ä—ã](#authorsRU)

---

## üßê –û –ø—Ä–æ–µ–∫—Ç–µ <a name="aboutRU"></a>

–ü—Ä–æ–µ–∫—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –±—ã—Å—Ç—Ä–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö. –•—ç—à-—Ç–∞–±–ª–∏—Ü–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ —è—á–µ–π–∫–∞–º –ø–∞–º—è—Ç–∏, –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—è –∫–æ–ª–ª–∏–∑–∏–∏ –∏ —É—Å–∫–æ—Ä—è—è –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º. –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è [–º–µ—Ç–æ–¥–æ–º —Ü–µ–ø–æ—á–µ–∫](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D0%B9).

–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–µ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ –∫–æ–¥–∞. –î–ª—è –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏–º–µ–Ω—è–ª–∏—Å—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã [Valgrind](https://valgrind.org/), [Kcachegrind](https://github.com/KDE/kcachegrind) –∏ [Perf](https://perf.wiki.kernel.org/index.php/Main_Page).

### –ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:
- –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏ `crc32` —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Intel Intrinsics.
- –£—Å–∫–æ—Ä–µ–Ω–∏–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Intel Intrinsics.
- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —è—á–µ–π–∫–∏ –≤ hash-bucket –Ω–∞ —è–∑—ã–∫–µ assembler x86-64 (NASM).
- –†–∞–∑–≤–µ—Ä—Ç–∫–∞ —Ü–∏–∫–ª–æ–≤ –∏ —Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏–≤–∞–Ω–∏–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏ `adler32`.

---

## ‚öôÔ∏è –ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã <a name="how_it_worksRU"></a>

–•—ç—à-—Ç–∞–±–ª–∏—Ü–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —É—Å–∫–æ—Ä–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –ª–∏–Ω–µ–π–Ω—ã–º –ø–æ–∏—Å–∫–æ–º. –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–∏–Ω—Ü–∏–ø ‚Äî –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ö—ç—à–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –µ–≥–æ –¥–ª—è –∞–¥—Ä–µ—Å–∞—Ü–∏–∏ –≤ –º–∞—Å—Å–∏–≤–µ –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ —á—Ç–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –∑–∞ **O(1)**. –û–¥–Ω–∞–∫–æ –∫–æ–ª–ª–∏–∑–∏–∏ (—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Ö—ç—à–µ–π –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö) –Ω–µ–∏–∑–±–µ–∂–Ω—ã. –í –ø—Ä–æ–µ–∫—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–µ—Ç–æ–¥ —Ü–µ–ø–æ—á–µ–∫: –∫–∞–∂–¥–∞—è —è—á–µ–π–∫–∞ –º–∞—Å—Å–∏–≤–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–≤—É—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º —Ö—ç—à–µ–º.

> [!NOTE]  
> –ü—Ä–æ–µ–∫—Ç —É—á–µ–±–Ω—ã–π, –ø–æ—ç—Ç–æ–º—É —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/4dyOrbF.jpeg" alt="–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã"></a>
</p>

### –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è (load factor)

–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è ‚Äî —ç—Ç–æ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ —á–∏—Å–ª–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–µ –∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —è—á–µ–µ–∫ –º–∞—Å—Å–∏–≤–∞. –° —Ä–æ—Å—Ç–æ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –∫–æ–ª–ª–∏–∑–∏–π, —á—Ç–æ —Å–Ω–∏–∂–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å. –í –ø—Ä–æ–µ–∫—Ç–µ –≤—ã–±—Ä–∞–Ω –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è **15**, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—â–∏–π –±–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–∞–º—è—Ç–∏. –ü—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ —ç—Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –≤ 2 —Ä–∞–∑–∞, –∏ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ—Ö—ç—à–∏—Ä—É—é—Ç—Å—è.

---

## üìà –ê–Ω–∞–ª–∏–∑ —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–π <a name="hash_functionsRU"></a>

–ò—Å—Å–ª–µ–¥–æ–≤–∞–ª–∞—Å—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—ã —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏—è–º–∏:
- **PJW32**
- **Adler32**
- **SDBM32**
- **FNV32**
- **Murmur3**
- **CRC32**

### –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–∞—Å—å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–∞ —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π:

```c++
struct string {
    char  *data;  // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç—Ä–æ–∫—É
    size_t size;  // –î–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
};
```

–¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ ‚Äî 19,289 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤ (–¥–ª–∏–Ω–∞ –¥–æ 32 —Å–∏–º–≤–æ–ª–æ–≤) –∏–∑ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π –®–µ–∫—Å–ø–∏—Ä–∞ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.

### –ú–µ—Ç–æ–¥–∏–∫–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π
–•—ç—à-—Ç–∞–±–ª–∏—Ü–∞ –∑–∞–ø–æ–ª–Ω—è–ª–∞—Å—å —Å–ª–æ–≤–∞—Ä–µ–º, –∞ –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏ bucket‚Äô–æ–≤ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª–∏—Å—å –≤ CSV –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ö—ç—à–µ–π.

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑–º–µ—Ä–µ–Ω–∏–π

#### PJW32
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [PJW hash function](https://en.wikipedia.org/wiki/PJW_hash_function), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –ü–∏—Ç–µ—Ä–æ–º –£–∞–π–Ω–±–µ—Ä–≥–µ—Ä–æ–º –≤ 1981 –≥–æ–¥—É. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ–±–∏—Ç–æ–≤—ã–µ –∏ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏. –•–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ –∏ —á–∏—Å–ª–∞–º–∏.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 3769.30
- **–ö–æ–¥**:
```c++
uint32_t pjw32(string *data, uint32_t modulo) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0;
    uint32_t test = 0;

    for (size_t i = 0; i < length; i++) {
        hash = (hash << 4) + (uint8_t)(message[i]);

        if ((test = (hash & 0xF0000000)) != 0) {
            hash = ((hash ^ (test >> 24)) & 0xFFFFFFF);
        }
    }

    return hash % modulo;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/ZFhm4Tg.png" alt="PJW32"></p>

#### Adler32
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [Adler-32](https://en.wikipedia.org/wiki/Adler-32), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –≤ 1995 –≥–æ–¥—É. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–≤–∞ 16-–±–∏—Ç–Ω—ã—Ö —á–∏—Å–ª–∞. –ë—ã—Å—Ç—Ä–∞—è –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å—Ç—Ä–æ–∫.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 587.01
- **–ö–æ–¥**:
```c++
uint32_t adler32(string *data) {
    const char *message = data->data;
    size_t      length  = data->size;

    uint32_t a = 1;
    uint32_t b = 0;

    for (size_t i = 0; i < length; i++) {
        a = (a + (uint8_t)(message[i])) % 65521;
        b = (b + a) % 65521;
    }

    return (b << 16) + a;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/wKQpBWL.png" alt="Adler32"></p>

#### SDBM32
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [SDBM](https://en.wikipedia.org/wiki/SDBM), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –≤ 1997 –≥–æ–¥—É. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ–±–∏—Ç–æ–≤—ã–µ –∏ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏. –•–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 20.71
- **–ö–æ–¥**:
```c++
uint32_t sdbm32(string *data) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0;

    for (size_t i = 0; i < length; i++) {
        hash = (uint8_t)(message[i]) + (hash << 6) + (hash << 16) - hash;
    }

    return hash;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/WHYCYpN.png" alt="SDBM32"></p>

#### FNV32
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [Fowler‚ÄìNoll‚ÄìVo](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –≤ 1991 –≥–æ–¥—É. –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å—Ç—Ä–æ–∫.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 18.11
- **–ö–æ–¥**:
```c++
uint32_t fnv32(string *data) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0x811C9DC5;

    for (size_t i = 0; i < length; i++) {
        hash ^= (uint8_t)(message[i]);
        hash *= 16777619;
    }

    return hash;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/1IDbXQq.png" alt="FNV32"></p>

#### Murmur3
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –≤ 2008 –≥–æ–¥—É. –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ö–æ—Ä–æ—à–µ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 17.66
- **–ö–æ–¥**:
```c++
uint32_t loadWord(const char *p) {
    return (uint32_t)((uint8_t)p[0])
           | ((uint8_t)p[1] << 8)
           | ((uint8_t)p[2] << 16)
           | ((uint8_t)p[3] << 24);
}

uint32_t rotl32(uint32_t x, int8_t r) {
    return (x << r) | (x >> (32 - r));
}

uint32_t murmur3Wrapper(string *data, uint32_t seed) {
    return murmur3(data, seed);
}

uint32_t murmur3(string *data, uint32_t seed) {
    const char *message = data->data;
    size_t length = data->size;

    const uint32_t c1 = 0xCC9E2D51;
    const uint32_t c2 = 0x1B873593;
    const uint32_t c3 = 0x85EBCA6B;
    const uint32_t c4 = 0xC2B2AE35;

    uint32_t h       = seed;
    size_t   nblocks = length / 4;

    for (size_t i = 0; i < nblocks; i++) {
        uint32_t k = loadWord(message + i * 4);
        k *= c1;
        k = rotl32(k, 15);
        k *= c2;

        h ^= k;
        h = rotl32(h, 13);
        h = h * 5 + 0xE6546B64;
    }

    const uint8_t *tail = (const uint8_t*)(message + nblocks * 4);
    uint32_t k1 = 0;

    switch (length & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
            k1 *= c1;
            k1 = rotl32(k1, 15);
            k1 *= c2;
            h ^= k1;
    }

    h ^= length;
    h ^= h >> 16;
    h *= c3;
    h ^= h >> 13;
    h *= c4;
    h ^= h >> 16;

    return h;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/airAcEB.png" alt="Murmur3"></p>

#### CRC32
- **–û–ø–∏—Å–∞–Ω–∏–µ**: [Cyclic redundancy check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check), –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞ –≤ 1961 –≥–æ–¥—É. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ–±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏.
- **–î–∏—Å–ø–µ—Ä—Å–∏—è**: 17.01
- **–ö–æ–¥**:
```c++
uint32_t crc32(string *data) {
    uint32_t crc32 = 0xFFFFFFFF;

    unsigned char *buffer = (unsigned char *)data->data;
    size_t         length = data->size;

    size_t quotient = length / 8;

    while (quotient--) {
        crc32 = _mm_crc32_u64(crc32, *(uint64_t *)buffer);
        buffer += 8;
    }

    if (length & 4) {
        crc32 = _mm_crc32_u32(crc32, *(uint32_t *)buffer);
        buffer += 4;
    }

    if (length & 2) {
        crc32 = _mm_crc32_u16(crc32, *(uint16_t *)buffer);
        buffer += 2;
    }

    if (length & 1) {
        crc32 = _mm_crc32_u8(crc32, *(uint8_t *)buffer);
    }

    return crc32 ^ 0xFFFFFFFF;
}
```
- **–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**:
  <p align="center"><img src="https://i.imgur.com/gPV8Cks.png" alt="CRC32"></p>

### –í—ã–±–æ—Ä –Ω–∞–∏–±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏
–ü—Ä–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è 15 —Ñ—É–Ω–∫—Ü–∏—è **`CRC32`** –ø–æ–∫–∞–∑–∞–ª–∞ –ª—É—á—à—É—é –¥–∏—Å–ø–µ—Ä—Å–∏—é (17.01), –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö. –ü–æ—ç—Ç–æ–º—É –æ–Ω–∞ –≤—ã–±—Ä–∞–Ω–∞ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π.

---

## üõ†Ô∏è –ü–ª–∞—Ç—Ñ–æ—Ä–º–æ–∑–∞–≤–∏—Å–∏–º—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ <a name="optimizationsRU"></a>

–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏–∑–º–µ—Ä—è–ª–æ—Å—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π `__rdtsc` (—Ç–∞–∫—Ç—ã –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞). –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:  
**Œ¥ = (1 - T_curr / T_prev) √ó 100%**,  
–∞–±—Å–æ–ª—é—Ç–Ω—ã–π:  
**Œî = (T_0 - T_curr) / T_0 √ó 100%**, –≥–¥–µ:
- **T_prev** ‚Äî –≤—Ä–µ–º—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏,
- **T_curr** ‚Äî –≤—Ä–µ–º—è —Ç–µ–∫—É—â–µ–π –≤–µ—Ä—Å–∏–∏,
- **T_0** ‚Äî –≤—Ä–µ–º—è –Ω–µ–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏.

> [!NOTE]  
> –¢–µ—Å—Ç—ã –ø—Ä–æ–≤–æ–¥–∏–ª–∏—Å—å –Ω–∞ Intel Core i5-1235U (12 —è–¥–µ—Ä, 16 –ø–æ—Ç–æ–∫–æ–≤, 10 –Ω–º, 1.3 –ì–ì—Ü, –±—É—Å—Ç –¥–æ 4.4 –ì–ì—Ü).

### –ë–∞–∑–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–π —Å —Ñ–ª–∞–≥–∞–º–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ `-O0` –∏ `-O3`:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –í—Ä–µ–º—è (-O0, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3, —Ç–∞–∫—Ç—ã) |
|-------------|---------------------|-------------------|
| PJW32       | 37,712,862,828      | 1,306,637,912     |
| Adler32     | 9,718,050,054       | 1,472,587,563     |
| SDBM32      | 5,339,882,153       | 1,319,988,597     |
| FNV32       | 5,637,812,992       | 1,303,962,430     |
| Murmur3     | 7,296,310,082       | 1,255,268,347     |
| CRC32       | 11,270,438,507      | 3,328,219,633     |

–û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∏ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å `-O3`:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|---------------------------|------------------------|
| PJW32       | 96.53%                    | 96.53%                 |
| Adler32     | 84.83%                    | 84.83%                 |
| SDBM32      | 75.36%                    | 75.36%                 |
| FNV32       | 76.92%                    | 76.92%                 |
| Murmur3     | 82.80%                    | 82.80%                 |
| CRC32       | 70.52%                    | 70.52%                 |

#### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏ crc32 —Å –ø–æ–º–æ—â—å—é Intel Intrinsics
–ì—Ä–∞—Ñ –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π (Kcachegrind) –ø–æ–∫–∞–∑–∞–ª, —á—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–µ –≤—Ä–µ–º—è —Ñ—É–Ω–∫—Ü–∏–∏ `crc32` –∑–∞–Ω–∏–º–∞–µ—Ç —Ü–∏–∫–ª –≤—ã—á–∏—Å–ª–µ–Ω–∏–π:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/3kx1NKG.png" alt="Kcachegrind crc32"></a>
</p>

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ `_mm_crc32_uXX` –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è. –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ñ—É–Ω–∫—Ü–∏–∏:

```c++
uint32_t crc32(string *data) {
    uint32_t crc32 = 0xFFFFFFFF;

    unsigned char *buffer = (unsigned char *)data->data;
    size_t         length = data->size;

    size_t quotient = length / 8;

    while (quotient--) {
        crc32 = _mm_crc32_u64(crc32, *(uint64_t *)buffer);
        buffer += 8;
    }

    if (length & 4) {
        crc32 = _mm_crc32_u32(crc32, *(uint32_t *)buffer);
        buffer += 4;
    }

    if (length & 2) {
        crc32 = _mm_crc32_u16(crc32, *(uint16_t *)buffer);
        buffer += 2;
    }

    if (length & 1) {
        crc32 = _mm_crc32_u8(crc32, *(uint8_t *)buffer);
    }

    return crc32 ^ 0xFFFFFFFF;
}
```

–í—Ä–µ–º—è —Å–æ–∫—Ä–∞—Ç–∏–ª–æ—Å—å —Å 3,328,219,633 –¥–æ 1,241,451,508 —Ç–∞–∫—Ç–æ–≤. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –í—Ä–µ–º—è (-O0, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics, —Ç–∞–∫—Ç—ã) |
|-------------|---------------------|-------------------|---------------------------------------|
| PJW32       | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         |
| Adler32     | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         |
| SDBM32      | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         |
| FNV32       | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         |
| Murmur3     | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         |
| CRC32       | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         |

–ü—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|---------------------------|------------------------|
| PJW32       | -0.53%                    | 96.51%                 |
| Adler32     | -1.28%                    | 84.65%                 |
| SDBM32      | 0.83%                     | 75.48%                 |
| FNV32       | -1.55%                    | 76.51%                 |
| Murmur3     | -1.33%                    | 82.56%                 |
| CRC32       | 62.69%                    | 88.98%                 |

#### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ strcmp —Å –ø–æ–º–æ—â—å—é Intel Intrinsics
–ü–æ—Å–ª–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ `crc32` —Ñ—É–Ω–∫—Ü–∏—è `strcmp` —Å—Ç–∞–ª–∞ —É–∑–∫–∏–º –º–µ—Å—Ç–æ–º:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/NWi0VVg.png" alt="Kcachegrind strcmp"></a>
</p>

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã `_mm256_loadu_si256` –∏ `_mm256_cmpeq_epi8` –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è. –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è:

```c++
inline int fastStrcmp(const char *a, const char *b) {
    __m256i va = _mm256_loadu_si256((const __m256i *)a);
    __m256i vb = _mm256_loadu_si256((const __m256i *)b);

    __m256i  cmp  = _mm256_cmpeq_epi8(va, vb);
    uint32_t mask = _mm256_movemask_epi8(cmp);

    return (mask != 0xFFFFFFFF);
}
```

–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –í—Ä–µ–º—è (-O0, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics, —Ç–∞–∫—Ç—ã) |
|-------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|
| PJW32       | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            |
| Adler32     | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            |
| SDBM32      | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            |
| FNV32       | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         | 1,331,798,050                                            |
| Murmur3     | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            |
| CRC32       | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            |

–ü—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|---------------------------|------------------------|
| PJW32       | -0.79%                    | 96.48%                 |
| Adler32     | 0.92%                     | 84.79%                 |
| SDBM32      | -0.29%                    | 75.41%                 |
| FNV32       | -0.57%                    | 76.37%                 |
| Murmur3     | -0.69%                    | 82.44%                 |
| CRC32       | 1.00%                     | 89.09%                 |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/dYRwIAV.png" alt="strcmp optimization"></a>
</p>

#### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —è—á–µ–π–∫–∏ –≤ hash-bucket –Ω–∞ —è–∑—ã–∫–µ assembler x86-64 (NASM)
–§—É–Ω–∫—Ü–∏—è `createNode` —Ç–∞–∫–∂–µ –æ–∫–∞–∑–∞–ª–∞—Å—å –≤ —Ç–æ–ø–µ –≤—ã–∑–æ–≤–æ–≤:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/4oiAZmc.png" alt="Kcachegrind createNode"></a>
</p>

–ê—Å—Å–µ–º–±–ª–µ—Ä–Ω–∞—è –≤–µ—Ä—Å–∏—è (NASM):

```nasm
section .text
global createNode
extern malloc, free

createNode:
    push rbx
    push r12
    push r13

    mov r12, rdi                ; wordPtr
    mov r13, rsi                ; length

    mov edi, 16
    call malloc
    test rax, rax
    jz .error

    mov rbx, rax
    mov [rbx + 8], r13          ; newNode->size = length

    lea rdi, [r13 + 1]
    call malloc
    test rax, rax
    jz .freeError

    mov [rbx], rax              ; newNode->data = rax

    mov rdi, rax                ; destination
    mov rsi, r12                ; source
    mov rcx, r13                ; length
    rep movsb                   ; copy length byte
    mov byte [rax + r13], 0

    mov rax, rbx                ; return newNode
    jmp .end

.freeError:
    mov rdi, rbx
    call free

.error:
    xor rax, rax

.end:
    pop r13
    pop r12
    pop rbx

    ret
```

–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –í—Ä–µ–º—è (-O0, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode, —Ç–∞–∫—Ç—ã) |
|-------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|------------------------------------------------------------------------|
| PJW32       | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            | 1,202,688,652                                                          |
| Adler32     | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            | 1,425,231,359                                                          |
| SDBM32      | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            | 1,193,839,445                                                          |
| FNV32       | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         | 1,331,798,050                                            | 1,219,107,790                                                          |
| Murmur3     | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            | 1,261,683,952                                                          |
| CRC32       | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            | 1,133,372,681                                                          |

–ü—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|---------------------------|------------------------|
| PJW32       | 9.16%                     | 96.81%                 |
| Adler32     | 3.55%                     | 85.34%                 |
| SDBM32      | 9.07%                     | 77.64%                 |
| FNV32       | 8.46%                     | 78.37%                 |
| Murmur3     | 1.50%                     | 82.71%                 |
| CRC32       | 7.78%                     | 89.94%                 |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/KFth290.png" alt="createNode optimization"></a>
</p>

#### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ adler32 —Å –ø–æ–º–æ—â—å—é –∞—Å—Å–µ–º–±–ª–µ—Ä–Ω—ã—Ö –≤—Å—Ç–∞–≤–æ–∫
–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `adler32` —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞—Å—Å–µ–º–±–ª–µ—Ä–Ω—ã—Ö –≤—Å—Ç–∞–≤–æ–∫ –¥–ª—è —Ä–∞–∑–≤–µ—Ä—Ç–∫–∏ —Ü–∏–∫–ª–æ–≤:

```c++
uint32_t adler32(string *data) {
    const char *message = data->data;
    size_t length = data->size;

    uint32_t a = 1;
    uint32_t b = 0;

    #ifdef OPTIMIZE_ADLER32

    size_t i = 0;

    for (; i + 4 <= length; i += 4) {
        uint32_t bytes;
        memcpy(&bytes, message + i, 4);

        __asm__ volatile (
                "mov    %1,    %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $8,    %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $16,   %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $24,   %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                : "+r"(a), "+r"(bytes), "+r"(b)
                :
                : "ecx"
        );
    }

    for (; i < length; i++) {
        a = (a + (uint8_t)(message[i])) % 65521;
        b = (b + a) % 65521;
    }

    a %= 65521;
    b %= 65521;

    #else
        for (size_t i = 0; i < length; i++) {
            a = (a + (uint8_t)(message[i])) % 65521;
            b = (b + a) % 65521;
        }
    #endif

    return (b << 16) + a;
}
```

–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –í—Ä–µ–º—è (-O0, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode, —Ç–∞–∫—Ç—ã) | –í—Ä–µ–º—è (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode + adler32, —Ç–∞–∫—Ç—ã) |
|-------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| PJW32       | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            | 1,202,688,652                                                          | 1,211,860,754                                                                   |
| Adler32     | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            | 1,425,231,359                                                          | 1,162,102,435                                                                   |
| SDBM32      | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            | 1,193,839,445                                                          | 1,185,024,245                                                                   |
| FNV32       | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         | 1,331,798,050                                            | 1,219,107,790                                                          | 1,171,217,440                                                                   |
| Murmur3     | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            | 1,261,683,952                                                          | 1,104,467,606                                                                   |
| CRC32       | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            | 1,133,372,681                                                          | 1,066,876,350                                                                   |

–ü—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|---------------------------|------------------------|
| PJW32       | -0.76%                    | 96.79%                 |
| Adler32     | 18.46%                    | 88.04%                 |
| SDBM32      | 0.74%                     | 77.80%                 |
| FNV32       | 3.93%                     | 79.23%                 |
| Murmur3     | 12.46%                    | 84.86%                 |
| CRC32       | 5.87%                     | 90.53%                 |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/w0DTpGm.png" alt="adler32 optimization"></a>
</p>

---

## üõê –ó–∞–∫–ª—é—á–µ–Ω–∏–µ <a name="conclusionRU"></a>

–ò—Å—Å–ª–µ–¥–æ–≤–∞–ª–∞—Å—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏–π –∏ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü. –ê–Ω–∞–ª–∏–∑ –ø–æ–∫–∞–∑–∞–ª, —á—Ç–æ `CRC32` –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ª—É—á—à–µ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Intel Intrinsics –∏ –∞—Å—Å–µ–º–±–ª–µ—Ä–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É—Å–∫–æ—Ä–∏–ª–∏ —Ä–∞–±–æ—Ç—É —Ñ—É–Ω–∫—Ü–∏–π `crc32`, `strcmp`, `createNode` –∏ `adler32`. –ò—Ç–æ–≥–æ–≤—ã–π –ø—Ä–∏—Ä–æ—Å—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

| –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è | –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç (%) |
|-------------|------------------------|
| PJW32       | 96.79%                 |
| Adler32     | 88.04%                 |
| SDBM32      | 77.80%                 |
| FNV32       | 79.23%                 |
| Murmur3     | 84.86%                 |
| CRC32       | 90.53%                 |

–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. –ü–ª–∞—Ç—Ñ–æ—Ä–º–æ–∑–∞–≤–∏—Å–∏–º—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã, –Ω–æ —Å–Ω–∏–∂–∞—é—Ç –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ—Å—Ç—å –∫–æ–¥–∞ –∏ —É—Å–ª–æ–∂–Ω—è—é—Ç –ø–æ–¥–¥–µ—Ä–∂–∫—É. –ò—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–ª–µ–¥—É–µ—Ç –æ—Ü–µ–Ω–∏–≤–∞—Ç—å —Å —É—á–µ—Ç–æ–º –∑–∞–¥–∞—á.

---

## ‚öôÔ∏è –£—Å—Ç–∞–Ω–æ–≤–∫–∞ <a name="installationRU"></a>

1. –°–∫–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏ –æ–±–Ω–æ–≤–∏—Ç–µ –ø–æ–¥–º–æ–¥—É–ª–∏:
   ```shell
   git clone git@github.com:lvbealr/HashTable.git
   cd HashTable
   git submodule update --init --remote --recursive
   ```
2. –°–∫–æ–º–ø–∏–ª–∏—Ä—É–π—Ç–µ –ø—Ä–æ–µ–∫—Ç:
   ```shell
   mkdir build && cd build
   cmake -S .. -B .
   make
   ```
3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É:
   ```shell
   ./HashTable <–ø—É—Ç—å_–∫_–≤—Ö–æ–¥–Ω—ã–º_–¥–∞–Ω–Ω—ã–º> <–ø—É—Ç—å_–∫_—Ç–µ—Å—Ç–æ–≤—ã–º_–¥–∞–Ω–Ω—ã–º>
   # –ü—Ä–∏–º–µ—Ä: ./HashTable ../txt/text.txt ../txt/test.txt
   ```

**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏**: GCC/Clang, CMake 3.10+, NASM.

---

## ‚õè –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã <a name="built_usingRU"></a>

- [CMake](https://cmake.org/) ‚Äî –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å–±–æ—Ä–∫–∏.
- [customWarning](https://github.com/lvbealr/customWarning) ‚Äî –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.
- [colorPrint](https://github.com/lvbealr/colorPrint) ‚Äî —Ü–≤–µ—Ç–Ω–æ–π –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å.

---

## ‚úç –ê–≤—Ç–æ—Ä—ã <a name="authorsRU"></a>

- [@lvbealr](https://github.com/lvbealr) ‚Äî —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è.

---

## üá∫üá∏ ENG <a name="ENG"></a>

## üìù Contents

- [About the Project](#aboutENG)
- [How it Works](#how_it_worksENG)
- [Hash Functions Analysis](#hash_functionsENG)
- [Platform-Dependent Optimizations](#optimizationsENG)
- [Conclusion](#conclusionENG)
- [Installation](#installationENG)
- [Built Using](#built_usingENG)
- [Authors](#authorsENG)

---

## üßê About the Project <a name="aboutENG"></a>

This project implements an optimized hash table for storing and quickly retrieving data. The hash table employs various hash functions to distribute data across memory cells, minimizing collisions and accelerating access. Collisions are resolved using the [chaining method](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution).

The element search function was optimized with minimal platform-dependent code. Profiling was performed using [Valgrind](https://valgrind.org/), [Kcachegrind](https://github.com/KDE/kcachegrind), and [Perf](https://perf.wiki.kernel.org/index.php/Main_Page).

### Performed Optimizations:
- Optimization of the `crc32` hash function using Intel Intrinsics.
- Acceleration of string comparison using Intel Intrinsics.
- Implementation of node creation and initialization in the hash table using x86-64 assembly (NASM).
- Loop unrolling and parallelization of the `adler32` hash function.

---

## ‚öôÔ∏è How the Hash Table Works <a name="how_it_worksENG"></a>

A hash table provides faster data access compared to linear search. The core principle is to compute a hash for each element and use it as an address in the data array. With proper implementation, read and write operations achieve **O(1)** complexity. However, collisions (when different data produce the same hash) are inevitable. The project uses chaining: each array cell contains a pointer to a doubly linked list of elements with the same hash.

> [!NOTE]  
> This is an educational project, so only unique data storage is considered.

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/4dyOrbF.jpeg" alt="Hash Table Structure"></a>
</p>

### Load Factor

The load factor is the ratio of the number of elements to the number of cells in the array. As the load factor increases, the probability of collisions rises, reducing performance. A load factor of **15** is used to balance performance and memory usage. When exceeded, the array size doubles, and data is rehashed.

---

## üìà Hash Functions Analysis <a name="hash_functionsENG"></a>

The performance of the hash table was analyzed with the following hash functions:
- **PJW32**
- **Adler32**
- **SDBM32**
- **FNV32**
- **Murmur3**
- **CRC32**

### Testing Parameters
The hash table stored structures of the form:

```c++
struct string {
    char  *data;  // Pointer to the string
    size_t size;  // Length of the string
};
```

Test data consisted of 19,289 unique words (up to 32 characters) from Shakespeare's works in lowercase.

### Measurement Methodology
The hash table was filled with the dictionary, and bucket occupancy data was exported to CSV for histogram plotting.

### Measurement Results

#### PJW32
- **Description**: [PJW hash function](https://en.wikipedia.org/wiki/PJW_hash_function), proposed by Peter Weinberger in 1981. Uses bitwise and arithmetic operations. Effective for short strings and numbers.
- **Variance**: 3769.30
- **Code**:
```c++
uint32_t pjw32(string *data, uint32_t modulo) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0;
    uint32_t test = 0;

    for (size_t i = 0; i < length; i++) {
        hash = (hash << 4) + (uint8_t)(message[i]);

        if ((test = (hash & 0xF0000000)) != 0) {
            hash = ((hash ^ (test >> 24)) & 0xFFFFFFF);
        }
    }

    return hash % modulo;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/ZFhm4Tg.png" alt="PJW32"></p>

#### Adler32
- **Description**: [Adler-32](https://en.wikipedia.org/wiki/Adler-32), proposed in 1995. Uses two 16-bit numbers. Fast and efficient for short strings.
- **Variance**: 587.01
- **Code**:
```c++
uint32_t adler32(string *data) {
    const char *message = data->data;
    size_t      length  = data->size;

    uint32_t a = 1;
    uint32_t b = 0;

    for (size_t i = 0; i < length; i++) {
        a = (a + (uint8_t)(message[i])) % 65521;
        b = (b + a) % 65521;
    }

    return (b << 16) + a;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/wKQpBWL.png" alt="Adler32"></p>

#### SDBM32
- **Description**: [SDBM](https://en.wikipedia.org/wiki/SDBM), proposed in 1997. Uses bitwise and arithmetic operations. Effective for short strings.
- **Variance**: 20.71
- **Code**:
```c++
uint32_t sdbm32(string *data) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0;

    for (size_t i = 0; i < length; i++) {
        hash = (uint8_t)(message[i]) + (hash << 6) + (hash << 16) - hash;
    }

    return hash;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/WHYCYpN.png" alt="SDBM32"></p>

#### FNV32
- **Description**: [Fowler‚ÄìNoll‚ÄìVo](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function), proposed in 1991. Efficient for short strings.
- **Variance**: 18.11
- **Code**:
```c++
uint32_t fnv32(string *data) {
    char  *message = data->data;
    size_t length  = data->size;

    uint32_t hash = 0x811C9DC5;

    for (size_t i = 0; i < length; i++) {
        hash ^= (uint8_t)(message[i]);
        hash *= 16777619;
    }

    return hash;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/1IDbXQq.png" alt="FNV32"></p>

#### Murmur3
- **Description**: [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash), proposed in 2008. Provides good distribution.
- **Variance**: 17.66
- **Code**:
```c++
uint32_t loadWord(const char *p) {
    return (uint32_t)((uint8_t)p[0])
           | ((uint8_t)p[1] << 8)
           | ((uint8_t)p[2] << 16)
           | ((uint8_t)p[3] << 24);
}

uint32_t rotl32(uint32_t x, int8_t r) {
    return (x << r) | (x >> (32 - r));
}

uint32_t murmur3Wrapper(string *data, uint32_t seed) {
    return murmur3(data, seed);
}

uint32_t murmur3(string *data, uint32_t seed) {
    const char *message = data->data;
    size_t length = data->size;

    const uint32_t c1 = 0xCC9E2D51;
    const uint32_t c2 = 0x1B873593;
    const uint32_t c3 = 0x85EBCA6B;
    const uint32_t c4 = 0xC2B2AE35;

    uint32_t h       = seed;
    size_t   nblocks = length / 4;

    for (size_t i = 0; i < nblocks; i++) {
        uint32_t k = loadWord(message + i * 4);
        k *= c1;
        k = rotl32(k, 15);
        k *= c2;

        h ^= k;
        h = rotl32(h, 13);
        h = h * 5 + 0xE6546B64;
    }

    const uint8_t *tail = (const uint8_t*)(message + nblocks * 4);
    uint32_t k1 = 0;

    switch (length & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
            k1 *= c1;
            k1 = rotl32(k1, 15);
            k1 *= c2;
            h ^= k1;
    }

    h ^= length;
    h ^= h >> 16;
    h *= c3;
    h ^= h >> 13;
    h *= c4;
    h ^= h >> 16;

    return h;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/airAcEB.png" alt="Murmur3"></p>

#### CRC32
- **Description**: [Cyclic redundancy check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check), proposed in 1961. Uses bitwise operations.
- **Variance**: 17.01
- **Code**:
```c++
uint32_t crc32(string *data) {
    uint32_t crc32 = 0xFFFFFFFF;

    unsigned char *buffer = (unsigned char *)data->data;
    size_t         length = data->size;

    size_t quotient = length / 8;

    while (quotient--) {
        crc32 = _mm_crc32_u64(crc32, *(uint64_t *)buffer);
        buffer += 8;
    }

    if (length & 4) {
        crc32 = _mm_crc32_u32(crc32, *(uint32_t *)buffer);
        buffer += 4;
    }

    if (length & 2) {
        crc32 = _mm_crc32_u16(crc32, *(uint16_t *)buffer);
        buffer += 2;
    }

    if (length & 1) {
        crc32 = _mm_crc32_u8(crc32, *(uint8_t *)buffer);
    }

    return crc32 ^ 0xFFFFFFFF;
}
```
- **Distribution**:
  <p align="center"><img src="https://i.imgur.com/gPV8Cks.png" alt="CRC32"></p>

### Selection of the Most Efficient Hash Function
With a load factor of 15, **`CRC32`** demonstrated the best variance (17.01), ensuring optimal data distribution. It was chosen for further optimizations.

---

## üõ†Ô∏è Platform-Dependent Optimizations <a name="optimizationsENG"></a>

Execution time was measured using the `__rdtsc` instruction (CPU cycles). Relative performance improvement:  
**Œ¥ = (1 - T_curr / T_prev) √ó 100%**,  
absolute:  
**Œî = (T_0 - T_curr) / T_0 √ó 100%**, where:
- **T_prev** ‚Äî previous version time,
- **T_curr** ‚Äî current version time,
- **T_0** ‚Äî unoptimized version time.

> [!NOTE]  
> Tests were conducted on an Intel Core i5-1235U (12 cores, 16 threads, 10 nm, 1.3 GHz, boost to 4.4 GHz).

### Baseline Results
Comparison of hash function execution times with `-O0` and `-O3` flags:

| Hash Function | Time (-O0, cycles) | Time (-O3, cycles) |
|---------------|---------------------|-------------------|
| PJW32         | 37,712,862,828      | 1,306,637,912     |
| Adler32       | 9,718,050,054       | 1,472,587,563     |
| SDBM32        | 5,339,882,153       | 1,319,988,597     |
| FNV32         | 5,637,812,992       | 1,303,962,430     |
| Murmur3       | 7,296,310,082       | 1,255,268,347     |
| CRC32         | 11,270,438,507      | 3,328,219,633     |

Performance improvements with `-O3`:

| Hash Function | Relative Improvement (%) | Absolute Improvement (%) |
|---------------|--------------------------|--------------------------|
| PJW32         | 96.53%                   | 96.53%                   |
| Adler32       | 84.83%                   | 84.83%                   |
| SDBM32        | 75.36%                   | 75.36%                   |
| FNV32         | 76.92%                   | 76.92%                   |
| Murmur3       | 82.80%                   | 82.80%                   |
| CRC32         | 70.52%                   | 70.52%                   |

#### CRC32 Optimization with Intel Intrinsics
A Kcachegrind call graph showed that the `crc32` function's main bottleneck was its computation loop:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/3kx1NKG.png" alt="Kcachegrind crc32"></a>
</p>

The `_mm_crc32_uXX` instructions were used for acceleration. New version:

```c++
uint32_t crc32(string *data) {
    uint32_t crc32 = 0xFFFFFFFF;

    unsigned char *buffer = (unsigned char *)data->data;
    size_t         length = data->size;

    size_t quotient = length / 8;

    while (quotient--) {
        crc32 = _mm_crc32_u64(crc32, *(uint64_t *)buffer);
        buffer += 8;
    }

    if (length & 4) {
        crc32 = _mm_crc32_u32(crc32, *(uint32_t *)buffer);
        buffer += 4;
    }

    if (length & 2) {
        crc32 = _mm_crc32_u16(crc32, *(uint16_t *)buffer);
        buffer += 2;
    }

    if (length & 1) {
        crc32 = _mm_crc32_u8(crc32, *(uint8_t *)buffer);
    }

    return crc32 ^ 0xFFFFFFFF;
}
```

Time reduced from 3,328,219,633 to 1,241,451,508 cycles. Results:

| Hash Function | Time (-O0, cycles) | Time (-O3, cycles) | Time (-O3 + crc32 Intrinsics, cycles) |
|---------------|---------------------|-------------------|---------------------------------------|
| PJW32         | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         |
| Adler32       | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         |
| SDBM32        | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         |
| FNV32         | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         |
| Murmur3       | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         |
| CRC32         | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         |

Performance improvements:

| Hash Function | Relative Improvement (%) | Absolute Improvement (%) |
|---------------|--------------------------|--------------------------|
| PJW32         | -0.53%                   | 96.51%                   |
| Adler32       | -1.28%                   | 84.65%                   |
| SDBM32        | 0.83%                    | 75.48%                   |
| FNV32         | -1.55%                   | 76.51%                   |
| Murmur3       | -1.33%                   | 82.56%                   |
| CRC32         | 62.69%                   | 88.98%                   |

#### strcmp Optimization with Intel Intrinsics
After optimizing `crc32`, `strcmp` became a bottleneck:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/NWi0VVg.png" alt="Kcachegrind strcmp"></a>
</p>

The `_mm256_loadu_si256` and `_mm256_cmpeq_epi8` instructions were used. New version:

```c++
inline int fastStrcmp(const char *a, const char *b) {
    __m256i va = _mm256_loadu_si256((const __m256i *)a);
    __m256i vb = _mm256_loadu_si256((const __m256i *)b);

    __m256i  cmp  = _mm256_cmpeq_epi8(va, vb);
    uint32_t mask = _mm256_movemask_epi8(cmp);

    return (mask != 0xFFFFFFFF);
}
```

Results:

| Hash Function | Time (-O0, cycles) | Time (-O3, cycles) | Time (-O3 + crc32 Intrinsics, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics, cycles) |
|---------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|
| PJW32         | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            |
| Adler32       | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            |
| SDBM32        | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            |
| FNV32         | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         | 1,331,798,050                                            |
| Murmur3       | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            |
| CRC32         | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            |

Performance improvements:

| Hash Function | Relative Improvement (%) | Absolute Improvement (%) |
|---------------|--------------------------|--------------------------|
| PJW32         | -0.79%                   | 96.48%                   |
| Adler32       | 0.92%                    | 84.79%                   |
| SDBM32        | -0.29%                   | 75.41%                   |
| FNV32         | -0.57%                   | 76.37%                   |
| Murmur3       | -0.69%                   | 82.44%                   |
| CRC32         | 1.00%                    | 89.09%                   |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/dYRwIAV.png" alt="strcmp optimization"></a>
</p>

#### Node Creation Optimization in x86-64 Assembly (NASM)
The `createNode` function was identified as a bottleneck:

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/4oiAZmc.png" alt="Kcachegrind createNode"></a>
</p>

An assembly version (NASM) was implemented:

```nasm
section .text
global createNode
extern malloc, free

createNode:
    push rbx
    push r12
    push r13

    mov r12, rdi                ; wordPtr
    mov r13, rsi                ; length

    mov edi, 16
    call malloc
    test rax, rax
    jz .error

    mov rbx, rax
    mov [rbx + 8], r13          ; newNode->size = length

    lea rdi, [r13 + 1]
    call malloc
    test rax, rax
    jz .freeError

    mov [rbx], rax              ; newNode->data = rax

    mov rdi, rax                ; destination
    mov rsi, r12                ; source
    mov rcx, r13                ; length
    rep movsb                   ; copy length byte
    mov byte [rax + r13], 0

    mov rax, rbx                ; return newNode
    jmp .end

.freeError:
    mov rdi, rbx
    call free

.error:
    xor rax, rax

.end:
    pop r13
    pop r12
    pop rbx

    ret
```

Results:

| Hash Function | Time (-O0, cycles) | Time (-O3, cycles) | Time (-O3 + crc32 Intrinsics, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode, cycles) |
|---------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|------------------------------------------------------------------------|
| PJW32         | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            | 1,202,688,652                                                          |
| Adler32       | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            | 1,425,231,359                                                          |
| SDBM32        | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            | 1,193,839,445                                                          |
| FNV32         | 5,637,812,992       | 1,303,962 blows,430     | 1,324,217,785                         | 1,331,798,050                                            | 1,219,107,790                                                          |
| Murmur3       | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            | 1,261,683,952                                                          |
| CRC32         | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            | 1,133,372,681                                                          |

Performance improvements:

| Hash Function | Relative Improvement (%) | Absolute Improvement (%) |
|---------------|--------------------------|--------------------------|
| PJW32         | 9.16%                    | 96.81%                   |
| Adler32       | 3.55%                    | 85.34%                   |
| SDBM32        | 9.07%                    | 77.64%                   |
| FNV32         | 8.46%                    | 78.37%                   |
| Murmur3       | 1.50%                    | 82.71%                   |
| CRC32         | 7.78%                    | 89.94%                   |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/KFth290.png" alt="createNode optimization"></a>
</p>

#### Adler32 Optimization with Assembly Inlines
The `adler32` function was optimized using assembly inlines for loop unrolling:

```c++
uint32_t adler32(string *data) {
    const char *message = data->data;
    size_t length = data->size;

    uint32_t a = 1;
    uint32_t b = 0;

    #ifdef OPTIMIZE_ADLER32

    size_t i = 0;

    for (; i + 4 <= length; i += 4) {
        uint32_t bytes;
        memcpy(&bytes, message + i, 4);

        __asm__ volatile (
                "mov    %1,    %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $8,    %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $16,   %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                "mov    %1,    %%ecx\n"
                "shr    $24,   %%ecx\n"
                "movzbl %%cl,  %%ecx\n"
                "addl   %%ecx, %0\n"
                "addl   %0,    %2\n"
                : "+r"(a), "+r"(bytes), "+r"(b)
                :
                : "ecx"
        );
    }

    for (; i < length; i++) {
        a = (a + (uint8_t)(message[i])) % 65521;
        b = (b + a) % 65521;
    }

    a %= 65521;
    b %= 65521;

    #else
        for (size_t i = 0; i < length; i++) {
            a = (a + (uint8_t)(message[i])) % 65521;
            b = (b + a) % 65521;
        }
    #endif

    return (b << 16) + a;
}
```

Results:

| Hash Function | Time (-O0, cycles) | Time (-O3, cycles) | Time (-O3 + crc32 Intrinsics, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode, cycles) | Time (-O3 + crc32 Intrinsics + strcmp Intrinsics + createNode + adler32, cycles) |
|---------------|---------------------|-------------------|---------------------------------------|----------------------------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| PJW32         | 37,712,862,828      | 1,306,637,912     | 1,313,601,291                         | 1,324,039,074                                            | 1,202,688,652                                                          | 1,211,860,754                                                                   |
| Adler32       | 9,718,050,054       | 1,472,587,563     | 1,491,444,247                         | 1,477,661,359                                            | 1,425,231,359                                                          | 1,162,102,435                                                                   |
| SDBM32        | 5,339,882,153       | 1,319,988,597     | 1,309,027,952                         | 1,312,882,939                                            | 1,193,839,445                                                          | 1,185,024,245                                                                   |
| FNV32         | 5,637,812,992       | 1,303,962,430     | 1,324,217,785                         | 1,331,798,050                                            | 1,219,107,790                                                          | 1,171,217,440                                                                   |
| Murmur3       | 7,296,310,082       | 1,255,268,347     | 1,272,084,617                         | 1,280,916,477                                            | 1,261,683,952                                                          | 1,104,467,606                                                                   |
| CRC32         | 11,270,438,507      | 3,328,219,633     | 1,241,451,508                         | 1,228,967,071                                            | 1,133,372,681                                                          | 1,066,876,350                                                                   |

Performance improvements:

| Hash Function | Relative Improvement (%) | Absolute Improvement (%) |
|---------------|--------------------------|--------------------------|
| PJW32         | -0.76%                   | 96.79%                   |
| Adler32       | 18.46%                   | 88.04%                   |
| SDBM32        | 0.74%                    | 77.80%                   |
| FNV32         | 3.93%                    | 79.23%                   |
| Murmur3       | 12.46%                   | 84.86%                   |
| CRC32         | 5.87%                    | 90.53%                   |

<p align="center">
  <a href="" rel="noopener">
 <img src="https://i.imgur.com/w0DTpGm.png" alt="adler32 optimization"></a>
</p>

---

## üõê Conclusion <a name="conclusionENG"></a>

The project investigated the optimization of hash functions and hash tables. Analysis showed that `CRC32` provides the best data distribution. Optimizations using Intel Intrinsics and assembly significantly accelerated the `crc32`, `strcmp`, `createNode`, and `adler32` functions. Final performance improvements:

| Hash Function | Absolute Improvement (%) |
|---------------|--------------------------|
| PJW32         | 96.79%                   |
| Adler32       | 88.04%                   |
| SDBM32        | 77.80%                   |
| FNV32         | 79.23%                   |
| Murmur3       | 84.86%                   |
| CRC32         | 90.53%                   |

Results depend on the implementation and platform. Platform-dependent optimizations are effective but reduce code portability and increase maintenance complexity. Their use should be evaluated based on specific tasks.

---

## ‚öôÔ∏è Installation <a name="installationENG"></a>

1. Clone the repository and update submodules:
   ```shell
   git clone git@github.com:lvbealr/HashTable.git
   cd HashTable
   git submodule update --init --remote --recursive
   ```
2. Build the project:
   ```shell
   mkdir build && cd build
   cmake -S .. -B .
   make
   ```
3. Run the program:
   ```shell
   ./HashTable <path_to_input_data> <path_to_test_data>
   # Example: ./HashTable ../txt/text.txt ../txt/test.txt
   ```

**Dependencies**: GCC/Clang, CMake 3.10+, NASM.

---

## ‚õè Built Using <a name="built_usingENG"></a>

- [CMake](https://cmake.org/) ‚Äî Build automation.
- [customWarning](https://github.com/lvbealr/customWarning) ‚Äî Custom warnings.
- [colorPrint](https://github.com/lvbealr/colorPrint) ‚Äî Colored console output.

---

## ‚úç Authors <a name="authorsENG"></a>

- [@lvbealr](https://github.com/lvbealr) ‚Äî Development and implementation.

---